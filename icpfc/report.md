## Intro
Недавно прошло очередное ежегодное онлайн соревнование [ICFP Contest'2018](https://icfpcontest2018.github.io/). В этом году мне все-таки удалось принять в нем участие, хоть и с трудом. Заданием этого года было написание алгоритма для бота(ов), основной задачей которого(ых) ,было напечатать/разобрать заданную фигуру в 3D. Максимальный размер области печати - 256х256х256. Набор команд по движению весьма ограничен и предполагает два типа движения: S (Straight), и L (Г - образное движение из двух частей) 
- S-движение  - это движение вдоль одной из осей координат, не более чем на 15 пикселей. 
- L-движение  - это движение состоящее из двух S с длиной не больше 5 пикселей.
На каждый ход тратится определенное количество энергии зависящее от количества ботов и размера области печати. Есть специальный режим, при включении которого можно печатать в любом месте пространства, не боясь что что-то "упадет" вниз. В этом режиме, количество энергии на поддержание системы возрастает в 10 раз. Задача - написать алгоритм для бота, который с минимальным количеством энергии выполнит поставленную задачу. Более подробно условия можно прочитать на [сайте организатора](https://icfpcontest2018.github.io/full/task-description.html)
Ну а теперь, собственно, о том, как мы участвовали<cut />

## 0. Сбор участников

Как человек, который многократно учавстовал в ICFP Contest, я вполне осознавал, что этим надо заниматься заранее, иначе в последнюю неделю надо будет бегать по всем и спрашивать не хотят ли они променять выходные на 72 часа адового программирования. Поэтому я начал задоооолго до начала (несколько месяцев). И набрал костяк команды, аж из 7(+/-2) человек, включая меня.
![image](https://user-images.githubusercontent.com/119268/43283579-f6430650-9121-11e8-8281-6b58f088e026.png)

Языком программирования был выбран [**Kotlin**](https://kotlinlang.org/), как язык, который был ближе всего и равнонеудобен всем :)

Как обычно это бывает, перед самым началом, люди начали отваливаться понемногу. Отпуска, родственники, лето. В общем форс мажоры кругом. ¯\\_(ツ)\_/¯. 
Итого нас осталось четверо, из которых двое коммитились только на часть контеста (Я и сам стартовал только со следующего дня)

## 1. Подготовка
К моменту начала, благодаря совместным усилиям, был готов репозиторий, создан базовый проект, в котором даже можно было запускать тесты, был установлен канал общения через Slack. В Slack были сразу прилинкованы боты, которые нас нотифицировали про любоые новости из твиттера, связанные с ICFPC. Удобненько. 
Совсем не хотелось терять время с правами, сборкой и запуском. Должен сказать, что в этом году все прошло более менее гладко, хотя сильно сказывалось то, что никто в своей работе не использует Kotlin в продакшне. Если кто-то спросит "почему же вы тогда этот язык использовали?", то я отвечу "Потому что ставка была на то, что в команде будут люди, которые с ним работают, но не сложилось. А на переправе, язык не меняют :)".

## 2. Начало
// Условие
Началось соревнование в 19:00 пятничного вечера, в то время как я тусил на корпоративе. Насколько мне известно, команда относительно 

23:00(+4Hrs) У нас есть базовые модельки данных, и на коленке написанный решатор, который должен отдать набор команд по заданному условию. Все идут спать. Пятница рабочий день первый день очень тяжело

## 3. День первый (6 часов после начала)
01:10(+6Hrs) Перед сном Мне приходит в голову "гениальная идея" о том, что нам совсем даже не надо ничего строить. Ведь можно просто развернуть задачу задом наперед, и "разбирать модель". По моему мнению это должно нам сильно упростить логику и убрать необходимость обрабатывать варианты, когда мы себя застраиваем, или получаем пустоты. С этой идеей я засыпаю.

Вставать после корпоратива было очень тяжело :) И погода этому не способствовала. Так что к коллегам по ICFP я присоединился около 10 часов утра. К этому моменту мы собрались максимальным возможным составом (<< СОСТАВ >>)

10:00(+15Hrs) Мы разбираем задачи, я дочитываю условие. 

11:45(+16Hrs). Даша активно воюет с форматом данных и особенностями работы с unsigned данными в Kotlin'е. Мы умеем читать все, что нам надо... ну почти.

12:00(+17Hrs). Мы долго обсуждаем вариант с обьеданием и разворотом модели. По каким-то магическим причинам нам кажется, что не может быть все просто. и мы перепроверям возможные корнеркейсы, когда наш алгоритм не сможет работать. К этому времени у нас получается построить карту пространства с высчитанными 

14:00(+19Hrs). Алгоритм вроде бы есть и написан, но проход из точки А в точку Б затруднен тем фактом, что необходимо использовать только заданные варианты ходов, и в который раз мы натыкаемся на то, что "а может. все-таки попробовать выучить и начать использовать А*?". Бот промахивается, очень долго планирует как ему ходить в заданную точку.

15:30(+20Hrs). Первый работающий алгоритм, у которого есть функция `gotoAndEat`. Для того, чтобы съедать фигуру, мы ддобавляем дополнительную команду `Erase`, которая в последсвии при развороте набора команд превращается в `Fill`. В процессе мы немного отхватываем с тем, что пропускаем пару команд и не всегда правильно разворачиваем все координаты, которые там надо. In soviet Russia пустая клеточка заполняет бота.

15:50(+20Hrs). Нельзя просто так взять и проитерироваться в тройном вложенном цикле `x in minx..maxx, y in miny..miny, z in minz..maxz`. Слишком много возможностей для простой ошибки в виде копипаста. Уж не помню. зачем нам это надо было, но наш валидатор отказыался пропускать наши решения
```
for (x in min.x..max.x) {
 for (y in min.x..max.x) {
  for (z in min.x..max.x) {
```
16:00(+21Hrs). Мы наконец-то умеем считать энергию правильно. И у нас есть возможность сравнивать наши решения друг с другом. До этого мы эксплуатировали сайт организаторов, что было не очень удобно. Тут же фиксим очередной баг, связанный с тем, что мы после каждого шага отдаем не польностью сапдеченный `state`, из-за чего мы пытаемся "есть" одни и те же клетки несколько раз подряд.

17:21(+22Hrs). Несмотря на то, что мы успешно решаем многие простые задачки, мы замечаем, что наш бот подозрительно долго скитается по простанству для печати. Обнаруживаем, что вместо того, чтобы идти к бличней точке из возможных, он выбирает дальнюю. Несмотря на то, что на визуализации это выглядело очень впечатляюще (работа кипит, бот бегает), данный подход был весьма неэффективен.
```
- val coordsToReach = builder.coords().toMutableList()
+ val coordsToReach = builder.coords().reversed().toMutableList()
```
Разворачивать команды мы тоже забыли
```
- return commmands
+ return commmands.reversed()
```

17:28(+22Hrs). Делаем базовый солвер, и запускаем его на всех задачах, распределяя группы задач между нашими компьютерами.

18:02(+23Hrs). Нельзя просто так взять и не забыть тот факт, что мы не можем ходить сквозь заполненные клетки. Из-за того, что мы "объедали" модельку, мы не столктулись с этой проблемой аж до 18 задачи ¯\\_(ツ)\_/¯.

18:52(+23Hrs). Мы собираем все возможные решения, которые смогли, и отсылаем их на сторону сервера. Из-за долгого поиска пути мы успеваем посчитать (всего?) 33 задачи из 186. Сложно оценивать, насколько это хороший результат, но мы точно в топ 42, потому что ровно столько команд отправили решения на lighting round :). 

19:00(+24Hrs). Организаторы выкладывают новую часть решения, в котором появляются новые виды задач: разбор модели (мы внутренее хихикаем, т.к. у нас уже все из коробки готово, просто нужно убрать разворот команд для бота), и пересборка модели (когда из одной модельки нужно собрать другую). Добавлены команды для ботов, которые позволяют сразу заполнять/удалять линию, прямоугольник, и параллеллепипед. Очень удобные команды, для того, чтобы заполнять/удалять большие объемы моделек. Забегая наперед, должен сказать, что этими командами нам так и не удалось воспользоваться в результате.

21:00(+26Hrs). В виду того, что Lighting Round закончился, и есть где развернуться. мы распределяем свои силы. Из запланированых задач 
- микро-сервер, который должен агрегировать лучшие из решений и складывать их в удобное для последующего отсылки место
- оптимизация нашего поиска (здесь мы добавили самый простой ограничивающий куб, чтобы не пытаться искать решения где-то вдалеке, если можно это сделать в рамках направления на заданную точку)
- тюнинг нашего поискового алгоритма, который выбирает из возможных точек такую, из которой в последствие не надо будет двигаться (до этого у нас прямо обязательно надо было сделать ход, перед тем как построить/съесть ячейку)
- куча флагов, влияющих на алгорим. Мы их агрегируем для возможности локально проверять любые решения, без ломания основных.

22:15(+27Hrs). Мы осознаем, что нас бот излишне осторожен, и может строить лишь в 6ти направлениях из 18 возможных.

## 4. День второй (~30 часов после начала)

01:28(+30Hrs). По состоянию на +30 часов - мы 17е. В некоторых задачах - мы первые(sic!). Мы считаем, что это круто, но ночь впереди, а мы ночью будем спать.

03:21(+32Hrs). Я, игнорируя наше правило "всегда спать ночью", добавляю `bounding box` для построения пути.

![image](https://user-images.githubusercontent.com/119268/43682457-78fbc3bc-987e-11e8-8e70-2da708d5f0dc.png)

09:24(+38Hrs). Финальные правки для локального сервера, который теперь может обрабатывать решения, без указания задания.
09:27(+38Hrs). Мы осознаем, что наш алгорим считает все оооочень долго для моделей с около миллиона точек. Простыми вычислениями мы понимаем, что для того, чтобы посчитать все вовремя, нам понадобится машина времени, чтобы запустить решение за два дня до начала соревнований.

**Random messages from chat**
> Ох, я только встал. Сейчас душ поем и буду выходить  
> Не ешь душ.

10:00(+39Hrs). Мы считаем что свои решения мы будем отправлять на amazon bucket, с указанием затраченного количества энергии. Мы встраиваем эту логику в наши решаторы, чтобы не тратить драгоценное CPU время для перерешивания задач.

13:28(+43Hrs). Мы окончательно избавляемся от локального сервера, на который потратили около 8 человекочасов (facepalm). Заводим Jenkins и начинам бегать задачи на нем. План минимум - к 72 часам иметь решения ко всем задачам ~500. Остается меньше половины времени, а наши алгоритмы ползают как черепахи. За работу с несколькими ботами еще никто не брался.

14:26(+44Hrs). Мы полностью подвели наши алгоримы под возможность запускаться из Command-Line'a. Наш скрипт прогоняет решение на заданной задаче, считает количество энергии и отсылает результат на Amazon. Леша концентрируется на новом алгоритме, идея которого заключается в том, чтобы посчитать скелет, который можно съесть без опасения того, что какие-то части останутся в подвешенном состоянии, и держать этот скелет актуальным по мере последующего съедения. Наши Jenkins с переменным успехом начинает считать задачки.

15:28(+45Hrs). Мы наконец-то можем решать задачки типа Reassemble, когда на вход дается одна модель, а на выходе должна получиться другая. Самым быстрым решением, что мы смогли придумать было - разбираем первую модель, собираем вторую. Это нам позволило быть алгоритмонезависимыми, хоть и не очень эффективными.

16:15(+46Hrs) Леша начинает активно тестировать жадный алгоритм. На фоне нашего предыдущего решения он выглядит лучше по всем задачам.

18:00(+48Hrs). Обнаруживаем, что наш алгоритм на больших задачах иногда перестает находить возможные пути. Связано это с тем, что мы зарываемся в модель, и наш ограничивающий куб дает слишком маленькое пространство для того, чтобы была возможность построить возможный путь.

18:35(+48Hrs). Первые мультиботы отправляются решать задачки. В виду того, что мы до сих пор смутно понимаем, как должны работать разделение и слияние,  мы держим две переменные bot1 и bot2 и пытаемся их скоординировать. После того, как боты закончат работу, мы ищем точку, между ними, ведем к ней, и делаем слияние. Для того чтобы должным образом не оставлять висящие куски модели в пространстве, мы позволяем ботам есть только в том, случае, если они не нарушают целостность конструкции модели. В случае, если боту нечего делать, он просто ждет следующего возможного случая. Синхронизация ботов весьма проста - в случае, если путь бота пересекается с другим ботом, он просто ждет. Код выглядит более чем ужасно, но тем, не менее, выглядит рабочим.

19:00(+49Hrs). Мы заводим выбор алгоритма под командную строку, и запускаем мультиботов решать задачи. Мультиботы ожидаемо рвут в хлам одноботные решения.

**Random messages from chat**
> build solution - #39 Failure after 6 hr 12 min 😿

19:56(+50Hrs). Мы убираем из всех алгоритмов знание о том, какую задачу они решают, превращая все алгоритмы в алгоритм разбора. Надстройка сверху отвечает за то, чтобы отдавать алгоритмам правильное состояние системы и разворот. Эта же надстройка отвечает за то, чтобы разворачивать команды, для разных типов задач. Код становится чище и потенциально безопаснее.

23:00(+53Hrs). Переписываем алгоритм мультиботов на высокоуровневые команды, отвечающие за свои части (разделение ботов, объединение, и пр.). Мультиботы - теперь частный случай, и мы можем собирать наш алгоритм из частей. Так, если алгоритм не знает, как разделять ботов, мы можем сделать это за него, и отдать ему состояние, в котором он решит задачу, а после этого, другая часть соберет ботов обратно в точку и отправит домой.

## 5. День тратий (~54 часов после начала)

01:39(+55Hrs). Леша ускоряет свой алгоритм почти что в 60(sic!) раз. Пожертвовав необходимостью ненужного пересчета состояния. Теперь, мы по идее можем успевать решать самые большие задачи.

**Random messages from chat**
> На 50 задаче кеширование доступных точек 105s -> 68s
> Отказ от  State дал 4s (68 -> 64)
> Убрал матрицу - 64 -> 33
> На 186 путь считается 1ms в 60 раз)

8:00(+62Hrs). Проснувшись, мы наблюдаем странную картину. Несмотря на то, что Лешин алгоритм работает очень быстро, мы теряем время на верификации решения. Потратив 5 c половиной часов на решение задачи, мы тратим столько же на верификацию o_O

**Random messages from chat**
> Done with 74 (20622.991). Verifying...
> Done verification in 20519 seconds. With 2481175342640 energy

8:29(+62Hrs). Мы обнаруживаем, что наши доблестные строители, подкидывают нам чудо иженерной мысли, не считаясь с законами физики. 

![image](https://user-images.githubusercontent.com/119268/43754761-128b6cac-9a15-11e8-9f61-2f15f36d42ef.png)

Добавляем ожидание чтобы боты ждали друг друга перед перемещением на следующий уровень
> Reached 973 (3114) of 3198 of 36
> Reached 972 (3111) of 3198 of 36
> Bot 1 Will wait for another bot while moving to the next ground




