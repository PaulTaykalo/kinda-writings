## Intro
Недавно прошло очередное ежегодное онлайн соревнование [ICFP Contest'2018](https://icfpcontest2018.github.io/). В этом году мне все-таки удалось принять в нем участие, хоть и с трудом. Заданием этого года было написание алгоритма для бота(ов), основной задачей которого(ых) ,было напечатать/разобрать заданную фигуру в 3D. Максимальный размер области печати - 256х256х256. Набор команд по движению весьма ограничен и предполагает два типа движения: S (Straight), и L (Г - образное движение из двух частей) 
- S-движение  - это движение вдоль одной из осей координат, не более чем на 15 пикселей. 
- L-движение  - это движение состоящее из двух S с длиной не больше 5 пикселей.
На каждый ход тратится определенное количество энергии зависящее от количества ботов и размера области печати. Есть специальный режим, при включении которого можно печатать в любом месте пространства, не боясь что что-то "упадет" вниз. В этом режиме, количество энергии на поддержание системы возрастает в 10 раз. Задача - написать алгоритм для бота, который с минимальным количеством энергии выполнит поставленную задачу. Более подробно условия можно прочитать на [сайте организатора](https://icfpcontest2018.github.io/full/task-description.html)
Ну а теперь, собственно, о том, как мы участвовали<cut />

## 0. Сбор участников

Как человек, который многократно учавстовал в ICFP Contest, я вполне осознавал, что этим надо заниматься заранее, иначе в последнюю неделю надо будет бегать по всем и спрашивать не хотят ли они променять выходные на 72 часа адового программирования. Поэтому я начал задоооолго до начала (несколько месяцев). И набрал костяк команды, аж из 7(+/-2) человек, включая меня.
![image](https://user-images.githubusercontent.com/119268/43283579-f6430650-9121-11e8-8281-6b58f088e026.png)

Языком программирования был выбран [**Kotlin**](https://kotlinlang.org/), как язык, который был ближе всего и равнонеудобен всем :)

Как обычно это бывает, перед самым началом, люди начали отваливаться понемногу. Отпуска, родственники, лето. В общем форс мажоры кругом. ¯\\_(ツ)\_/¯. 
Итого нас осталось четверо, из которых двое коммитились только на часть контеста (Я и сам стартовал только со следующего дня)

## 1. Подготовка
К моменту начала, благодаря совместным усилиям, был готов репозиторий, создан базовый проект, в котором даже можно было запускать тесты, был установлен канал общения через Slack. В Slack были сразу прилинкованы боты, которые нас нотифицировали про любоые новости из твиттера, связанные с ICFPC. Удобненько. 
Совсем не хотелось терять время с правами, сборкой и запуском. Должен сказать, что в этом году все прошло более менее гладко, хотя сильно сказывалось то, что никто в своей работе не использует Kotlin в продакшне. Если кто-то спросит "почему же вы тогда этот язык использовали?", то я отвечу "Потому что ставка была на то, что в команде будут люди, которые с ним работают, но не сложилось. А на переправе, язык не меняют :)".

## 2. Начало
// Условие
Началось соревнование в 19:00 пятничного вечера, в то время как я тусил на корпоративе. Насколько мне известно, команда относительно 

23:00(+4Hrs) У нас есть базовые модельки данных, и на коленке написанный решатор, который должен отдать набор команд по заданному условию. Все идут спать. Пятница рабочий день первый день очень тяжело

## 3. День первый (6 часов после начала)
01:10(+6Hrs) Перед сном Мне приходит в голову "гениальная идея" о том, что нам совсем даже не надо ничего строить. Ведь можно просто развернуть задачу задом наперед, и "разбирать модель". По моему мнению это должно нам сильно упростить логику и убрать необходимость обрабатывать варианты, когда мы себя застраиваем, или получаем пустоты. С этой идеей я засыпаю.

Вставать после корпоратива было очень тяжело :) И погода этому не способствовала. Так что к коллегам по ICFP я присоединился около 10 часов утра. К этому моменту мы собрались максимальным возможным составом (<< СОСТАВ >>)

10:00(+15Hrs) Мы разбираем задачи, я дочитываю условие. 

11:45(+16Hrs). Даша активно воюет с форматом данных и особенностями работы с unsigned данными в Kotlin'е. Мы умеем читать все, что нам надо... ну почти.

12:00(+17Hrs). Мы долго обсуждаем вариант с обьеданием и разворотом модели. По каким-то магическим причинам нам кажется, что не может быть все просто. и мы перепроверям возможные корнеркейсы, когда наш алгоритм не сможет работать. К этому времени у нас получается построить карту пространства с высчитанными 

14:00(+19Hrs). Алгоритм вроде бы есть и написан, но проход из точки А в точку Б затруднен тем фактом, что необходимо использовать только заданные варианты ходов, и в который раз мы натыкаемся на то, что "а может. все-таки попробовать выучить и начать использовать А*?". Бот промахивается, очень долго планирует как ему ходить в заданную точку.

15:30(+20Hrs). Первый работающий алгоритм, у которого есть функция `gotoAndEat`. Для того, чтобы съедать фигуру, мы ддобавляем дополнительную команду `Erase`, которая в последсвии при развороте набора команд превращается в `Fill`. В процессе мы немного отхватываем с тем, что пропускаем пару команд и не всегда правильно разворачиваем все координаты, которые там надо. In soviet Russia пустая клеточка заполняет бота.

15:50(+20Hrs). Нельзя просто так взять и проитерироваться в тройном вложенном цикле `x in minx..maxx, y in miny..miny, z in minz..maxz`. Слишком много возможностей для простой ошибки в виде копипаста. Уж не помню. зачем нам это надо было, но наш валидатор отказыался пропускать наши решения
```
for (x in min.x..max.x) {
 for (y in min.x..max.x) {
  for (z in min.x..max.x) {
```
16:00(+21Hrs). Мы наконец-то умеем считать энергию правильно. И у нас есть возможность сравнивать наши решения друг с другом. До этого мы эксплуатировали сайт организаторов, что было не очень удобно. Тут же фиксим очередной баг, связанный с тем, что мы после каждого шага отдаем не польностью сапдеченный `state`, из-за чего мы пытаемся "есть" одни и те же клетки несколько раз подряд.

17:21(+22Hrs). Несмотря на то, что мы успешно решаем многие простые задачки, мы замечаем, что наш бот подозрительно долго скитается по простанству для печати. Обнаруживаем, что вместо того, чтобы идти к бличней точке из возможных, он выбирает дальнюю. Несмотря на то, что на визуализации это выглядело очень впечатляюще (работа кипит, бот бегает), данный подход был весьма неэффективен.
```
- val coordsToReach = builder.coords().toMutableList()
+ val coordsToReach = builder.coords().reversed().toMutableList()
```
Разворачивать команды мы тоже забыли
```
- return commmands
+ return commmands.reversed()
```

17:28(+22Hrs). Делаем базовый солвер, и запускаем его на всех задачах, распределяя группы задач между нашими компьютерами.

18:02(+23Hrs). Нельзя просто так взять и не забыть тот факт, что мы не можем ходить сквозь заполненные клетки. Из-за того, что мы "объедали" модельку, мы не столктулись с этой проблемой аж до 18 задачи ¯\\_(ツ)\_/¯.

18:52(+23Hrs). Мы собираем все возможные решения, которые смогли, и отсылаем их на сторону сервера. Из-за долгого поиска пути мы успеваем посчитать (всего?) 33 задачи из 186. Сложно оценивать, насколько это хороший результат, но мы точно в топ 42, потому что ровно столько команд отправили решения на lighting round :). 

19:00(+24Hrs). Организаторы выкладывают новую часть решения, в котором появляются новые виды задач: разбор модели (мы внутренее хихикаем, т.к. у нас уже все из коробки готово, просто нужно убрать разворот команд для бота), и пересборка модели (когда из одной модельки нужно собрать другую). Добавлены команды для ботов, которые позволяют сразу заполнять/удалять линию, прямоугольник, и параллеллепипед. Очень удобные команды, для того, чтобы заполнять/удалять большие объемы моделек. Забегая наперед, должен сказать, что этими командами нам так и не удалось воспользоваться в результате.

21:00(+26Hrs). В виду того, что Lighting Round закончился, и есть где развернуться. мы распределяем свои силы. Из запланированых задач 
- микро-сервер, который должен агрегировать лучшие из решений и складывать их в удобное для последующего отсылки место
- оптимизация нашего поиска (здесь мы добавили самый простой ограничивающий куб, чтобы не пытаться искать решения где-то вдалеке, если можно это сделать в рамках направления на заданную точку)
- тюнинг нашего поискового алгоритма, который выбирает из возможных точек такую, из которой в последствие не надо будет двигаться (до этого у нас прямо обязательно надо было сделать ход, перед тем как построить/съесть ячейку)
- куча флагов, влияющих на алгорим. Мы их агрегируем для возможности локально проверять любые решения, без ломания основных.

22:15(+27Hrs). Мы осознаем, что нас бот излишне осторожен, и может строить лишь в 6ти направлениях из 18 возможных.

## 4. День второй (~30 часов после начала)

01:28(+30Hrs). По состоянию на +30 часов - мы 17е. В некоторых задачах - мы первые(sic!). Мы считаем, что это круто, но ночь впереди, а мы ночью будем спать.

03:21(+32Hrs). Я, игнорируя наше правило "всегда спать ночью", добавляю `bounding box` для построения пути.

![image](https://user-images.githubusercontent.com/119268/43682457-78fbc3bc-987e-11e8-8e70-2da708d5f0dc.png)

09:24(+38Hrs). Финальные правки для локального сервера, который теперь может обрабатывать решения, без указания задания.
09:27(+38Hrs). Мы осознаем, что наш алгорим считает все оооочень долго для моделей с около миллиона точек. Простыми вычислениями мы понимаем, что для того, чтобы посчитать все вовремя, нам понадобится машина времени, чтобы запустить решение за два дня до начала соревнований.

**Random messages from chat**
> Ох, я только встал. Сейчас душ поем и буду выходить  
> Не ешь душ.

10:00(+39Hrs). Мы считаем что свои решения мы будем отправлять на amazon bucket, с указанием затраченного количества энергии. Мы встраиваем эту логику в наши решаторы, чтобы не тратить драгоценное CPU время для перерешивания задач.

13:28(+43Hrs). Мы окончательно избавляемся от локального сервера, на который потратили около 8 человекочасов (facepalm). Заводим Jenkins и начинам бегать задачи на нем. План минимум - к 72 часам иметь решения ко всем задачам ~500. Остается меньше половины времени, а наши алгоритмы ползают как черепахи. За работу с несколькими ботами еще никто не брался.

14:26(+44Hrs). Мы полностью подвели наши алгоримы под возможность запускаться из Command-Line'a. Наш скрипт прогоняет решение на заданной задаче, считает количество энергии и отсылает результат на Amazon. Леша концентрируется на новом алгоритме, идея которого заключается в том, чтобы посчитать скелет, который можно съесть без опасения того, что какие-то части останутся в подвешенном состоянии, и держать этот скелет актуальным по мере последующего съедения. Наши Jenkins с переменным успехом начинает считать задачки.

15:28(+45Hrs). Мы наконец-то можем решать задачки типа Reassemble, когда на вход дается одна модель, а на выходе должна получиться другая. Самым быстрым решением, что мы смогли придумать было - разбираем первую модель, собираем вторую. Это нам позволило быть алгоритмонезависимыми, хоть и не очень эффективными.

16:15(+46Hrs) Леша начинает активно тестировать жадный алгоритм. На фоне нашего предыдущего решения он выглядит лучше по всем задачам.

18:00(+48Hrs). Обнаруживаем, что наш алгоритм на больших задачах иногда перестает находить возможные пути. Связано это с тем, что мы зарываемся в модель, и наш ограничивающий куб дает слишком маленькое пространство для того, чтобы была возможность построить возможный путь.

18:35(+48Hrs). Первые мультиботы отправляются решать задачки. В виду того, что мы до сих пор смутно понимаем, как должны работать разделение и слияние,  мы держим две переменные bot1 и bot2 и пытаемся их скоординировать. После того, как боты закончат работу, мы ищем точку, между ними, ведем к ней, и делаем слияние. Для того чтобы должным образом не оставлять висящие куски модели в пространстве, мы позволяем ботам есть только в том, случае, если они не нарушают целостность конструкции модели. В случае, если боту нечего делать, он просто ждет следующего возможного случая. Синхронизация ботов весьма проста - в случае, если путь бота пересекается с другим ботом, он просто ждет. Код выглядит более чем ужасно, но тем, не менее, выглядит рабочим.

19:00(+49Hrs). Мы заводим выбор алгоритма под командную строку, и запускаем мультиботов решать задачи. Мультиботы ожидаемо рвут в хлам одноботные решения.

**Random messages from chat**
> build solution - #39 Failure after 6 hr 12 min 😿

19:56(+50Hrs). Мы убираем из всех алгоритмов знание о том, какую задачу они решают, превращая все алгоритмы в алгоритм разбора. Надстройка сверху отвечает за то, чтобы отдавать алгоритмам правильное состояние системы и разворот. Эта же надстройка отвечает за то, чтобы разворачивать команды, для разных типов задач. Код становится чище и потенциально безопаснее.

23:00(+53Hrs). Переписываем алгоритм мультиботов на высокоуровневые команды, отвечающие за свои части (разделение ботов, объединение, и пр.). Мультиботы - теперь частный случай, и мы можем собирать наш алгоритм из частей. Так, если алгоритм не знает, как разделять ботов, мы можем сделать это за него, и отдать ему состояние, в котором он решит задачу, а после этого, другая часть соберет ботов обратно в точку и отправит домой.

## 5. День трeтий (~54 часов после начала)

01:39(+55Hrs). Леша ускоряет свой алгоритм почти что в 60(sic!) раз. Пожертвовав необходимостью ненужного пересчета состояния. Теперь, мы по идее можем успевать решать самые большие задачи.

**Random messages from chat**
> На 50 задаче кеширование доступных точек 105s -> 68s  
> Отказ от  State дал 4s (68 -> 64)  
> Убрал матрицу - 64 -> 33  
> На 186 путь считается 1ms в 60 раз)  

8:00(+62Hrs). Проснувшись, мы наблюдаем странную картину. Несмотря на то, что Лешин алгоритм работает очень быстро, мы теряем время на верификации решения. Потратив 5 c половиной часов на решение задачи, мы тратим столько же на верификацию o_O

**Random messages from chat**
> Done with 74 (20622.991). Verifying...  
> Done verification in 20519 seconds. With 2481175342640 energy

8:29(+62Hrs). Мы обнаруживаем, что наши доблестные строители, подкидывают нам чудо иженерной мысли, не считаясь с законами физики. Кроме этого сегодня - понедельник, и нас остается трое. Трое невыспанных зомби. У Леши, к тому же, вечером поезд.

![image](https://user-images.githubusercontent.com/119268/43754761-128b6cac-9a15-11e8-9f61-2f15f36d42ef.png)

Добавляем ожидание чтобы боты ждали друг друга перед перемещением на следующий уровень
> Reached 973 (3114) of 3198 of 36  
> Reached 972 (3111) of 3198 of 36  
> Bot 1 Will wait for another bot while moving to the next ground  

10:38(+64Hrs). Наш Jenkins умирает. Мы, осознаем, что 8 задач на решение успели съесть по 8 Гигабайт+ каждая. Спасает только хард резет, который услжняется тем, что всю память мы тоже выели. Потушили сервер, и стартонули заново. Как оказалось, причиной были мультиботы, которые находясь в соседних клетках, не могли разойтись с миром, и ждали пока каждый из них закончит операцию. В добавок ко всему эти джентельмены не забывали сообщать о соих действиях в консоль, что и вылилось в многие гигабайты логов, о том как два сверхвежливых бота решают подождать, пока другой сделает свою работу.

| Bot1 |  Bot2 |  
|:-----------------------:|:-----------------------:|  
| ![](https://media.giphy.com/media/5AcR8w022Gk4E/giphy.gif) | ![](https://media.giphy.com/media/l0Iy8I6QBKzt6dDyg/giphy.gif) |

12:48(+66Hrs). Мы почти в 0 урезаем наш верификатор для Лешиного алгоритма, оставляя только самое важное. Запускаем на решение все нерешенные задачи. В течение следующего часа мы получаем ответы почти на все задачи.

13:00(+67Hrs). Мы всеми правдами и не правдами пытаемся прикрутить мультиботов к Лешиному алгоритму. Отсутсвие полного верификатора очень сильно бьет по нам, и мы не понимаем, почему наши решения отказываются проходить. 

15:00(+69Hrs). Нельзя просто так взять и прикрутить алгоритм из нескольких частей, так чтобы он работал правильно. Где-то забыли развернуть команды, где-то два раза ботов возвращали в начальную точку.

16:45(+70Hrs). Мы обложились кучей дополнительных данных, логами, и трейсами, но 100% вероятности в удачности исхода нашего решения, все еще не можем дать.

17:38(+71Hrs). За чуть больше чем час до окончания, у нас остаются нерешенными 13 задач из 488. Мы с Лешей, который уже сидит в поезде пытаемся скоординировать наши действия по нахождению причины из-за которой наши боты носятся по всей карте, сталкиваясь друг с другом

18:25(+72Hrs). Зная, что под конец соревнования могут быть большие проблемы с отправкой результатов, мы отправляем промежуточный результат наших решений. Остаются нерешенными 5 задач.

18:45(+72Hrs). Мы, наконец-то находим багу, в которой мы неправильно пересекали два множества точек
> A ∩ B ∩ C ≠ A ∩ (B ∪ C)
 ```
 val commonPoints = affectedPoints.intersect(matrix.filledCoordinates).intersect(volatile)`
 vs
 val commonPoints = affectedPoints.intersect(matrix.filledCoordinates.plus(volatile))`
 ```
 Мы натравливаем наших мультиботов на начальные небольшие задачки.
 
 18:58(+72Hrs). Отправляем наши финальные решения. Остаются нерешенными 3 задачи.
 
 ## 6. После окончания соревнования
 
 19:05. Мы на 57 месте (за 6 часов до окончания).
 20:08. Досчитываются оставшиеся 3 задачи.
 23:24. Леша отправляет нам посмотреть, как наши мультиботы всемером разбираются с первой задачкой.  
 ![7-bots-solution](https://user-images.githubusercontent.com/119268/43815783-011e3312-9ada-11e8-84de-7b9b3ddfcaa8.gif)
 ??:??. Мы осознаем, что наши мультиботы поломались на задачах "собрать-разобрать", так что в финальном результате у нас порядка 23 неправильных решений. ¯\\_(ツ)\_/¯
 
## 7. Послесовие, Выводы и Благодарности.
 
**Команда**: Forth Major  
**Место в Lightigh Round**: ~17 за 6 часов до окончания
**Место в Main Round**: ~54 за 6 часов до окончания
**Состав-людей-которые-все-таки-смогли-пусть-и-не-все-72-часа**:  
- Darina Chernysheva (@sunstream)
- Pavlo Chernyshev (@cronos)
- Paul Taykalo (@tt.kilew)
- Kostya Bychkov (@xNekOIx)
- Alexey Demedeckiy (@daloog)

**Отдельная Благодарочка**:
- Sergey Zenchenko (@zen)

**Что сработало**  
- Заранее подготовленная структура проекта и учетки на gitlab (на момент начала у всех были доступы)
- Командная работа и разделение по фичам.
- Тесты

**Что в следующий раз можно сделать лучше**
- Чуток подтянуть алгоритмы
- Чуть больше проверок, особенно на финальные результаты
- Браться за алгоритмы, которые принесут нам в N раз больше(мультиботы, группы) пораньше, а не пытаться выжать максимум из базового алгоритма.
- Оценивать скорость решений и переделывать, если мы явно не успеваем.
- Заставлять подписываться кровью участников, чтобы не искать оных в последний момент.
- Почитать язык программирования, на котором будет участие немного заранее.
- Научиться делать быстрые, проверенные решения )


P.S. Хочу сказать большое спасибо всем учавствовавшим, что смогли выделить такой большой промежуток времени для общего блага :). Могли бы сделать больше? Могли %) Но как говорится, человек человеку - волк, а невыспавшийся человек - зомби зомби зомби.
Удачи. До встречи в следующем году.
 
 
 





